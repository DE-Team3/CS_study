# 인덱스
데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조이다. 데이터를 찾을 때 테이블 전체를 조건과 비교하는 '풀 테이블 스캔(Full Table Scan)'이 필요한데 인덱스를 사용하면 조건에 맞는 데이터를 빠르게 찾을 수 있다. 책의 목차나 찾아보기의 개념이다.

![image](https://user-images.githubusercontent.com/108858121/209040115-aae74d16-a3c3-4e33-8406-81ba8351a997.png)

<br>

## 인덱스의 장점
- 테이블 검색 속도와 성능 향상
- 그에 따른 시스템의 전반적인 부하 감소
- 정렬된 형태의 데이터를 갖기 때문에 ORDER BY문이나 MIN/MAX 같은 쿼리 빠르게 수행 가능

## 인덱스의 단점
- 인덱스를 관리하기 위한 추가 작업 필요
- 추가 저장 공간 필요
- 인덱스 된 필드에서 데이터를 업데이트 하거나 레코드를 추가 혹은 삭제 시 성능 저하
- 데이터 변경 작업이 자주 일어날 경우 인덱스를 재작성해야함

<br>

## 인덱스 사용시 유리한 경우
- 규모가 큰 테이블
- 데이터의 중복도가 낮은 Column
- Where절에서 자주 사용되는 Column
- 외래키가 사용되는 Column
- Join에 자주 사용되는 Column

## 인덱스 사용시 불리한 경우
- Data 중복도가 높은 Column
- DML이 자주 일어나는 Column

<br>

## 인덱스의 자료구조
앞에서 언급했듯이 인덱스는 데이터 저장, 수정, 삭제에 대한 성능을 희생시켜 탐색 성능을 대폭 상승시키는 방식이다. 그렇다면 인덱스는 많은 자료 구조 중에 왜 'B-Tree'를 사용할까?

### 인덱스 Tree 자료구조에 대한 이해
탐색에 대한 시간 복잡도가 높은 자료구조

![image](https://user-images.githubusercontent.com/108858121/209042276-ef1f5e6e-7097-47ee-91a6-e12619e0ad7f.png)

탐색에 대한 시간 복잡도가 낮은 자료구조

![image](https://user-images.githubusercontent.com/108858121/209042215-705482ea-2c96-48dd-a719-6d635d7bdf7c.png)

<br>

> ### 밸런스 트리  
> 트리의 노드가 한 쪽으로 쏠리지 않도록 노드 삽입 및 삭제 시 특정 규칙에 맞게 재정렬하여 양쪽 자식 수의 밸런스를 유지해야한다. 하지만, 노드 삽입 및 삭제 시 발생하는 재정렬 작업 때문에
탐색을 제외한 작업에서는 일반 Tree보다 성능이 좋지 않다.

<br>

### 1. 해시 테이블
해시 테이블은 key와 value를 한 쌍으로 데이터를 저장하는 자료구조이다.

해시 테이블을 이용하면 인덱스는 (key, value)=(컬럼의 값, 데이터의 위치)로 구현함

하지만 해시 테이블은 부등호(<,>)가 아니라 등호(=) 연산에만 최적화 되어있기 때문에 인덱스에서 잘 사용되지 않음

### 2. B-Tree
![image](https://user-images.githubusercontent.com/108858121/209045940-9c7e1e91-9e90-48ff-ab2c-e266704297c4.png)

B-Tree는 이렇게 노드 하나에 여러 데이터가 저장됨. 각 노드에는 여러 개의 Key를 가지고 각 Key에 대응하는 Data도 함께 가짐

항상 정렬된 상태기 때문에 특정 값보다 크고 작은 부등호 연산에 문제가 없고 데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 보다 낮은 시간 복잡도를 가짐

### 3. B+-Tree
![image](https://user-images.githubusercontent.com/108858121/209046668-a91a02c2-1c0c-4d35-9d67-5d7336522249.png)

기존의 B-Tree는 어느 한 데이터의 검색은 효율적이지만, 모든 데이터를 한 번 순회하는 데에는 트리의 모든 노드를 방문해야 하므로 비효율적임 이러한 B-Tree의 단점을 개선시킨 자료구조가 B+-Tree

Leaf Node만 인덱스와 함께 데이터를 가지고 있고, 나머지 노드(Inner Node)들은 데이터를 위한 인덱스(Key)만을 가짐

리프노드까지 가지 않아도 탐색할 수 있는 B-Tree에 비해 무조건 리프노드까지 가야한다는 단점도 있음

## 인덱스 만드는 법
- MySQL  
    - 클러스터형 인덱스 : primary key 옵션으로 기본키로 만들거나 unique not null 옵션을 붙이면 생성 가능, 테이블 당 하나
    - 세컨더리 인덱스 : create index... 명령어 기반으로 생성 가능

- MongoDB
    - 문서(Document)를 만들면 자동으로 ObjectID가 형성디고 해당 키가 기본 키로 설정됨. 세컨더리키도 부가적으로 성정하여 복합 인덱스로 생성 가능

## 인덱스 최적화 기법
- 인덱스는 비용이므로 불필요한 곳에 설정하는 것은 비효율적임 필요에 따라 조정
- 인덱스를 만들 때 항상 테스팅하여 시간 복잡도를 최소화
- 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순으로 생성

## 참조
https://velog.io/@sem/DB-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0-B-Tree  
https://mangkyu.tistory.com/96  
https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/%5BDB%5D%20Index.md