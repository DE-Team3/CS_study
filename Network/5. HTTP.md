# HTTP
  ## HTTP란?
  - Hyper Text Transfer Protocol의 약자로 하이퍼 텍스트 문서를 주고 받기 위한 프로토콜이다.
  - 클라이언트에서 요청(request)을 보내면 서버에서 응답(response)을 하는 형식
  - 기본 포트는 80 포트
  - 연결 상태를 유지하지 않는 무상태(Stateless), 비연결성(Connectionless) 프로토콜
    - 무상태(Stateless) : 서버가 클라이언트의 이전 상태를 보존하지 않고 요청을 처리하는 것
    - 비연결성(Connectionless) : 서버에 연결하고 요청해서 응답을 받으면 연결을 끊어 버리는 것
  ## HTTP/0.9
  - HTTP 초기 버전을 구분하기 위해 부르는 버전으로 1990년 등장
  - 요청은 단일 라인이며, method는 GET만 존재
  - 헤더가 없으며, HTML 파일만 전송 가능
  - 응답은 HTML 파일 내용 자체로 되어 있음
<br>

# HTTP/1.0
  ## 특징
  - 1996년 요청과 응답에 HTTP 헤더 개념이 도입되어, 메타데이터를 주고 받고 프로토콜을 유연하고 확장 가능하도록 개선
  - HEAD, POST method 추가
  - 버전 정보 확인 가능
  - 상태 코드가 추가 되어 요청의 성공과 실패 여부 파악이 가능해짐
  - Content Type 도입으로 HTML 이외의 문서 전송이 가능해짐
  ## 한계
  - 커넥션 하나에 요청과 응답 각각 한개만 처리 가능
  - 새로운 연결이 발생할 때 마다 3-Way Handshake 발생
  - RTT가 증가하는 문제 발생  
    ![RTT](https://user-images.githubusercontent.com/61510481/211167222-fd60cb28-bffc-4921-8ff7-f2892b69b99f.png)  
    - **RTT(Round Trip Time)** : 패킷이 목적지에 도달한 뒤 해당 패킷에 대한 응답이 출발지로 다시 돌아오기까지의 시간
    - 이미지 스플리팅, 코드압축, 이미지 Base64 인코딩 등의 방법 등을 사용하여 문제를 해결하고자 했다
      - 이미지 스플리팅 : 많은 이미지가 합쳐 있는 하나의 이미지를 다운 받고 백그라운드를 기반으로 이미지를 표기하는 방법
      - 코드 압축 : 코드를 압축해서 개행문자, 빈칸 등을 없애 크기를 최소화 하는 방법
      - 이미지 Base64 인코딩 : 이미지를 64진법으로 이루어진 문자열로 인코딩 하는 방법. 서버에 HTTP 요청을 하지 않아도 되지만 크기가 커진다는 단점이 있음.
<br>

# HTTP/1.1
  ## 특징
  - 1997년 등장 후 현재 가장 많이 쓰이고 있는 표준
  - Persistent Connection 추가로 지정된 시간 동안 커넥션을 닫지 않고 요청과 응답을 처리 하도록 개선
  - Pipelining 기능 추가로 앞 요청의 응답을 기다리지 않고 여러 요청을 연속적으로 보내고 그 순서에 맞춰 응답을 받는 방식 가능  
  ## 한계
  - 무거운 헤더 구조
    - 연결을 끊지 않고 유지하고 있기 때문에 요청 시 마다 중복된 쿠키 정보가 계속 헤더에 포함됨
  - HOL(Head Of Line) Blocking 발생
    - 같은 큐에 있는 패킷이 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 문제  

  ![http1_1](https://user-images.githubusercontent.com/61510481/211209260-0b305d19-164d-4011-a002-a0be70b6e204.png)  
<br>

# HTTP/2
  ## 특징
  - 기존 HTTP 1.n 버전의 성능 향상의 초점을 맞춰 등장한 프로토콜
  - 기존 표준의 대체가 아닌 확장을 위한 것
  - Binary Protocol
    - Binary 계층을 추가해서 메세지를 프레임 단위로 나누고 이를 바이너리 인코딩을 해서 전송
    - 파싱속도와 전송속도가 증가되고 오류 발생 가능성이 감소하게 됨
    - 서버는 클라이언트 측에서 
    - 각 프레임에는 프레임 헤더가 포함되고, 헤더 내부에 프레임 식별자가 있어서 수신 측에서 응답 순서 상관없이 받아도 순서대로 재배치 가능
      - Binary : 0과 1로 이루어진 데이터 형식
      - Frame : HTTP/2에서 통신의 최소 단위, 프레임이 모여 하나의 메세지가 된다
  - Multiplexed Streams
    - 기존 HTTP1.1의 Pipelining을 개선
    - 응답은 요청 순서에 상관없이 Stream을 기반으로 받기 때문에 HOL Blocking 문제 해결 가능
    - Stream : 구성된 연결 내에서 전달되는 바이트의 양방향 흐름, 하나 이상의 메시지가 전달 가능
  - Stream Prioritization
    - 리소스의 우선순위 설정 가능
    - 응답에 대한 우선순위를 정해 우선순위가 높을 수록 응답을 빨리 할 수 있어 HOL Blocking 문제 해결 가능
  - 서버 푸시(Server Push)
    - 클라이언트가 요청하기 전에 미리 리소스를 로드해서 보냄(ex. html파일만을 요청했는데 css파일을 html파일과 함께 미리 보내 줌)
    - 클라이언트의 요청을 최소화 하여 대기시간을 줄일 수 있다
  - 헤더 압축(Header Compression)
    - 헤더를 압축하여 페이지 로드 시간 감소
    - 헤더 정보를 허프만 코딩 압축 방식을 기반으로 하는 HPACK 압축 방식을 이용해서 압축 전송
    - 클라이언트와 서버는 각각 Header Table을 관리하고 이전 요청과 동일한 필드는 table의 index만 보내고, 변경되는 값은 인코딩 후 보내 헤더의 크기를 경량화
      - 허프만 코딩 방식 : 데이터 문자의 빈도에 따라서 다른 길이의 부호를 사용하는 알고리즘
   ## 한계
  - 각 요청마다 Stream으로 구분해서 병렬적으로 처리하지만, 결국 이에는 TCP 고유의 HOL Blocking이 존재
  - 이러한 TCP의 태생적인 HOL Blocking을 해결하기 위해 QUIC / HTTP3.0이 등장

  ## HTTP 방식 요약
  ![http1_to_2](https://user-images.githubusercontent.com/61510481/211210369-0f3d71da-9976-4c1a-9b05-902314341fc0.png)   
<br>

# HTTPS
 애플리케이션 계층과 전송 계층 사이에  SSL/TLS 계층을 넣어 통신을 암호화한 신뢰할 수 있는 HTTP 요청
 
  ## SSL/TLS
  - 웹에서의 데이터는 가로채면 누구나 읽을 수 있는 일반 텍스트 형태로 전송 되었기 때문에 보안상 이슈가 있었다.
  - 전송 계층에서 데이터를 암호화 하여 보안을 제공하는 프로토콜
  - 처음 SSL(Secure Socket Layer)1.0을 시작으로 현재는 TLS(Transport Layer Security Protocol)로 발전함 보통 이를 합쳐 SSL/TLS로 부른다
  - 보안세션을 기반으로 데이터를 암호화 하며 이때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 사용된다
  ### 보안세션
  보안 세션이란 보안이 시작되고 끝나는 동안 유지되는 세션이며, SSL/TLS는 핸드셰이크를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보 등을 공유한다.
  - 사이버 슈트 : 프로토콜. AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약이며, 다섯 개가 있다.
  - AEAD 사이퍼 모드 : 데이터 암호화 알고리즘이며 AES_128_GCM, AES_256_GCM 등이 있다.
  
  ### 인증 메커니즘
  CA(Certificate Authorities)에서 발급한 인증서를 기반으로 이루어진다. CA에서 발급한 인증서는 공개키를 클라이언트에 제공하고 사용자의 서버를 신뢰할 수 있는 서버임을 보장한다. 인증서는 서비스 정보, 공개키, 지문, 디지털 서명 등으로 이루어져 있다.
  - CA 발급과정 : 사이트 정보와 공개키를 CA에 제출 -> CA는 공개키를 해시한 값인 지문을 사용하는 비밀키 등을 기반으로 CA 인증서 발급
  
  ### 암호화 알고리즘
  키 교환 암호화 알고리즘으로는 대수곡선 기반의 ECDHE 또는 모듈식 기반의 DHE를 사용하며, 둘 다 디피-헬만 방식을 근간으로 만들었다.    
  ![oneway_function](https://user-images.githubusercontent.com/61510481/212348298-62508ae7-0933-474e-8f56-3af07bd1d840.png)  
  - 디피_헬만 키 교환 암호화 알고리즘 : g와 x와 p를 안다면 y는 구하기 쉽지만 g와 y와 p를 안다면 x를 구하기 어렵다는 원리에 기반한 알고리즘(일방향 함수)
  
  ### 해싱 알고리즘
  데이터를 추정하기 힘든 더 작고, 섞여 있는 조가그로 만드는 알고리즘이다. SSL/TLS는 해싱 알고리즘으로 SHA-256, SHA-384 알고리즘을 쓰며, SHA-256을 가장 많이 사용한다.
  - SHA 256 알고리즘 : 해시 함수 결괏괎이 256비트인 알고리즘이다. 코인을 비롯한 많은 블록체인 시스템에서 사용되고 있다. 해싱을 해야 할 메세지에 전처리를 하고 전처리된 메세지를 기반으로 해시를 반환하는 방식사용.
  
# HTTP/3
  ## 특징
  - TCP 위에서 동작하는 HTTP/2와 달리 구글에서 개발한 QUIC 라는 계층 위에서 동작
    - QUIC(Quick UDP Internet Connections)
      - Google에서 개발한 UDP 기반의 전송 프로토콜
      - 첫 연결 설정에서 필요한 정보와 함께 데이터를 전송하소, 연결 성공 시 설정을 캐싱하여 다음 연결 때 바로 사용 가능
      - TLS 기본 적용과 IP Spoofing/ REplaty Attack 방지로 보안성 향상
      - 순방향 오류 수정 매커니즘(EFC)이 적용되어 전송한 패킷이 손실되어도 수신 측에서 에러를 검출하고 수정 가능
  - HTTP/2의 장점은 모두 가지고 있음
  - 초기 연결 설정 시 지연 시간 감소
