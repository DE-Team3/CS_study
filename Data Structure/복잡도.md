# 자료구조
자료구조(data structure)는 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합

**C++의 기본**
- C++ : STL을 기반으로 전반적인 자료구조를 가장 잘 설명할 수 있는 언어
- STL : C++의 표준 템플릿 라이브러리이자 스택, 배열 등 데이터 구조의 함수 등을 제공하는 라이브러리의 묶음
  
```
#include <bits/stdc++.h> // -- (1)
using namespace std; // -- (2)
string a; // -- (3)
int main()
{
  cin >> a; // -- (4)
  cout << a << "\n"; -- (5)
  return 0; // -- (6)
}
```
입력 -> wow  
출력 -> wow  
  
- c++은  main함수를 중심으로 돌아가기에 main함수를 무조건 하나 만들어야한다.
- 컴파일이 시작되면 전역변수 초기화, 라이브러리 import작업
- main함수에 얽혀 있는 함수들 작동
- main 함수가 0을 리턴하며 프로세스 종료  
1. 헤더파일, STL라이브러리 import, 이 중 bits/stdc++.h는 모든 표준 라이브러리가 포함된 헤더  
2. std라는 네임스페이스를 사용, cin이나 cout등을 사용 할 때 원래는 std::cin처럼 네임스페이스 달아서 호출하는데 이를 기본으로 설정 *네임스페이스 : 같은 클래스 이름 구별, 모듈화에 쓰이는 이름  *
3. 문자열 선언 <타입> <변수명> -> string이라는 타입을 가진 a라는 변수 정의. 예를들어 string a = "큰돌"이라면 a는 lvalue (추후 다시 사용될 수 있는 변수), 큰돌은 rvalue (한 번쓰고 다시 사용되지 않는 변수)
4. 입력 cin, scanf
5. 출력 cout와 printf  
6. return 0 -> 프로세스가 정상적으로 마무리 됨
  
# 복잡도
알고리즘을 고려할 때 시간복잡도와 공간복잡도를 고려하면 좋은 UX를 구현할 수 있다.  
  
**효율적인 알고리즘이란?**
알고리즘이 수행을 시작하여 결과가 도출될 때까지  
실행에 걸리는 시간이 짧고  *-> 시간복잡도*  
연산하는 컴퓨터 내의 메모리와 같은 자원을 덜 사용하는 것  *->  공간복잡도*

복잡도는 시간복잡도와 공간복잡도로 나뉜다.
  
## 시간복잡도
시간 복잡도란 '문제를 해결하는 데 걸리는 시간과 입력의 합수 관계'를 가리킨다.  
어떠한 알고리즘의 로직이 '얼마나 오랜 시간'이 걸리는지를 나타내는 데 쓰이며, 보통 **빅오표기법**으로 나타낸다.  
  
예를 들어 '입력 크기 n'의 모든 입력에 대한 알고리즘에 필요한 시간이  
(1) 10n³ + 2n³  
이라고 했을 때 코드로 나타내면  
```
for(int i = 0; i < 10; i++){
  for(int j = 0; j < n; j++){
    for(int d = 0; d < n; d++)
      for(int k = 0; k < n; k++)
      // 로직 O(1) if(a == b) ret ++;
  }
}
for(int i = 0; i < 2; i++){
  for(int j = 0; j < n; j++){
    for(int d = 0; d < n; d++){
    }
  }
}
```
빅오표기법으로 나타내면 n³
  
(2) 10n² + n  
이라고 했을 때 코드로 나타내면
```
for(int i = 0; i < 10; i++){
  for(int j = 0; j < n; j++){
    for(int k = 0; k < n; k++){
      if (true) cout << k << '\n';
    }
  }
}
for(int i = 0; i < n; i++){
  if (true) cout << k << '\n';
}
```
빅오표기법으로 나타내면 n²  
  
*최대 차수중에 앞의 상수를 빼고 뒤에 것을 뺀 형태*
  
**빅오표기법**  
입력 범위 n을 기준으로 해서 로직이 몇 번 반복되는지 나타내는 것 *O(n²)*  
*가장 영향을 많이 끼치는 항의 상수 인자를 빼고 나머지 항을 없앤 것*
입력 크기가 커질수록 연산량이 가장 많이 커지는 항은 n², 다른 것은 그에 비해 미미하기 때문에 증가속도를 고려한다면 다른 항들은 신경쓰지 않아도 된다는 이론
  
**시간복잡도는 왜 필요한가?**
- 시간 복잡도는 효율적인 코드로 개선하는 데 쓰이는 척도
- n²에서 n으로 변환시키는 것 => 시간복잡도를 줄여 효율적인 코드로 개선한 것
- 버튼을 누르고 화면이 나타나는데 이 로직이 O(n²)의 시간 복잡도를 가지고 9초가 걸린다고 가정할 때 O(n)의 시간 복잡도를 가지는 알고리즘으로 개선한다면 3초 걸림  
- 시간 복잡도의 속도 비교
![image](https://user-images.githubusercontent.com/108858076/209031058-2434a68b-12f5-435f-8565-f695e6cc0b11.png)  
  - O(1)과 O(n)은 입력 크기가 커질수록 차이가 많이 난다.
  - 속도순위 O(n²) < O(n) < O(1) -> O(1) 지향
  
## 공간복잡도
공간복잡도는 프로그램을 실행시켰을 때 필요로 하는 자원공간의 양을 말한다.(얼만큼의 메모리를 사용했는가? 주로 배열의 크기로 결정)  
정적 변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함한다.  
```
int a[1004];
```  
- a배열은 1004 x 4바이트의 크기를 가지게 되는데 이런 공간을 의미한다.  
  
> 시간 복잡도를 생각할 때 평균, 그리고 최악의 시간 복잡도를 고려하며 사용  
![image](https://user-images.githubusercontent.com/108858076/209037088-ce329237-08f4-49b7-966c-864e9f3ac07e.png)

#### 참고 https://blog.naver.com/PostView.nhn?blogId=jhc9639&logNo=221339684077&redirect=Dlog&widgetTypeCall=true&directAccess=false
