# 비선형 자료구조
선형 자료구조와 다르게 일렬로 나열되지 않고 자료의 순서나 관계가 복잡한 자료구조를 뜻한다.

## **그래프(Graph)**
정점과 정점 사이를 간선으로 연결하는 비선형 자료구조 

![image](https://user-images.githubusercontent.com/108858121/209493933-82c9692e-f157-4ed2-b0dd-429e59eb6293.png)
 

### **용어** 
- **정점 (vertex)** : 노드(node)라고도 하며 데이터가 저장되는 그래프 기본 원소
- **간선 (edge)** : 링크(link)라고도 하며 정점간의 관계를 나타냄
- **인접 정점 (adjacent vertex)** : 간선에 의해 연결된 정점 (A, C 는 서로 인접 정점)
- **단순 경로 (simple path)** : 동일한 간선을 지나지 않는 경로
- **차수 (degree)** : 무방향 그래프에서 한 정점에 인접한 정점의 수 (C의 차수는 2)
- **진출 차수 (out-degree)** : 방향 그래프에서 한 정점에서 다른 정점으로 나가는 간선의 수
- **진입 차수 (in-degree)** : 방향 그래프에서 외부에서 한 정점으로 들어오는 간선의 수
- **사이클 (cycle)** : 전체적인 경로를 봤을 때 경로의 순환이 발생하는 구조

### **특징**
- 환형 구조가 가능함 (Cycle)
- 간선이 자기 자신을 향할 수는 없음 (No Self Loop)
- 중복된 간선은 허용되지 않음 (No Multigraph)

### **종류**
그래프는 간선의 방향성 유무와 가중치에 따라 나눠진다.
- **무향 그래프 (Undirected graph)**  
    간선에 방향성을 갖지 않는 그래프이다. 1에서 2, 2에서 1의 이동이 모두 가능하다. 무향 그래프에서는 (1,2)와 (2,1)가 같은 간선임을 뜻한다.

    ![image](https://user-images.githubusercontent.com/108858121/209494648-1642641e-5d4e-44c7-8e26-f0ed91ae7579.png)

- **유향 그래프 (Directed graph)**  
    간선에 방향성을 갖는 그래프이다. (4,6)와 (6,4)가 각각 다른 간선을 나타내게 된다.

    ![image](https://user-images.githubusercontent.com/108858121/209494707-9dfe8315-17c5-4eaa-813e-85e93517421c.png)

- **가중치 그래프**  
    간선과 정점 사이에 드는 비용을 가중치라고 하는데 두 정점을 이동할 때 가중치를 나타내는 그래프가 가중치 그래프이다. 최단 거리나 최소 비용으로 이동하는 경로를 찾을 때 활용된다.

    ![image](https://user-images.githubusercontent.com/108858121/209495569-0bc7283d-d84a-4d45-9f31-9997b85e4f37.png)


### **그래프의 탐색**
첫 정점에서부터 모든 정점을 모두 한 번씩 방문하는 것
- **깊이 우선 탐색 (DFS)**  
    갈 수 있는 만큼 최대한 깊게 탐색하고 더이상 탐색할 정점이 없을 시 이전 정점으로 돌아감

- **넓이 우선 탐색 (BFS)**  
    시작 정점 방문 후 시작 정점에 인접한 모든 정점을 우선적으로 방문함

![그래프의탐색](https://user-images.githubusercontent.com/108858121/209495293-b36fe233-3e8e-4bc6-90d7-fefbbae041b6.gif)

<br>

## **트리(Tree)**
그래프의 일종으로 정점과 간선을 이용하여 데이터의 배치 형태를 추상화한 자료구조로 루트 노드, 내부 노드, 리프 노드 등으로 구성 됨

![image](https://user-images.githubusercontent.com/108858121/209496315-6604e10b-9599-483d-a815-513f04480386.png)

### **용어** 
- **루트 노드(root node)** : 가장 위에 있는 노드
- **내부 노드(internal node)** : 루트 노드와 리프 노드 사이에 있는 노드
- **리프 노드(leaf node)** : 더이상 자식 노드가 없는 노드
- **깊이** : 루트 노드부터 특정 노드까지 최단 거리를 뜻함 (4번 노드의 깊이는 2)
- **높이** : 루트 노드부터 리프 노드까지 거리 중 가장 긴 거리를 뜻함 (예시 트리의 높이는 3)
- **레벨** : 보통 깊이와 같은 의미이고 0번 노드가 0레벨이면 1번과 2번 노드는 1레벨이고, 0번 노드가 1레벨이면 1번과 2번 노드는 2레벨이 됨
- **서브 트리** : 트리 내의 하위 집합(혹은 부분집합)

### **특징**
- 리스트와 다르게 부모(parent)와 자식(child)의 계층적인 관계로 표현됨
- 데이터 저장보다는 저장된 데이터를 더 효과적으로 탐색하기 위해서 사용됨
- 환형 구조(cycle)가 존재하지 않음
- 루트노드를 제외한 모든 노드는 단 하나의 부모노드를 가짐

### **종류**
### **이진 트리 (Binary Tree)**  
부모 노드 밑의 자식 노드 개수(=차수, degree)를 최대 2개로 제한하는 가장 간단한 형태의 트리

- **편향 이진 트리 (Skewed Binary Tree)**  
    하나의 차수로만 이루어져 있는 트리이다. 이러한 구조는 배열(리스트)와 같은 선형 구조이므로 리프 노드를 탐색 시 모든 데이터를 탐색해야한다는 단점이 있다.

    ![image](https://user-images.githubusercontent.com/108858121/209497515-c0f43daa-6e06-4f7d-9a60-1dd46b586544.png)

- **포화 이진 트리 (Full Binary Tree)**  
    리프 노드를 제외한 모든 노드의 차수가 2개로 이루어져 있는 트리이다. 해당 차수에 몇 개의 노드가 존재하는지 바로 알 수 있으므로 노드의 개수를 파악할 때 용이한 장점이 있다.

    ![image](https://user-images.githubusercontent.com/108858121/209497639-15343675-8a1b-43e7-8018-09ee67bef6d3.png)

- **완전 이진 트리 (Complete Binary Tree)**  
    포화 이진 트리와 같은 개념으로 트리를 생성하지만, 모든 노드가 왼쪽부터 차근차근 생성되는 이진 트리를 의미한다.

    ![image](https://user-images.githubusercontent.com/108858121/209497686-c3aba669-a3b5-4984-9f1e-0726d58f5a91.png)

- **이진 탐색 트리 (Binary Search Tree)**  
    노드의 왼쪽 가지에는 노드의 값보다 작은 값들만 있고, 오른쪽 가지에는 큰 값들만 있도록 구성된 트리

    ![binary-search-tree-insertion-animation](https://user-images.githubusercontent.com/108858121/209497845-1a410e62-e77f-4b36-abe4-c47a4233a3e3.gif)

- **균형 이진 탐색 트리 (AVL Tree)**  
    극단적인 이진 탐색 트리를 보완하여 리밸런싱한 트리, 균형인수(왼쪽 서브 트리의 높이 - 오른쪽 서브 트리의 높이)의 절댓값이 2 이상인 경우를 극단적인 상황으로 판단하고 리밸런싱을 수행한다.  

    **<극단적 상황의 이진 탐색 트리>**

    ![image](https://user-images.githubusercontent.com/108858121/209498150-adb82c0f-866e-45fa-a67e-cc67efee4953.png)

    **<리밸런싱한 트리>**
    
    ![image](https://user-images.githubusercontent.com/108858121/209498253-f7b13038-9205-452a-8c37-5d115d391ae6.png)

- **레드-블랙 트리(red-black tree)**  
    레드-블랙 트리는 각각의 노드가 레드나 블랙인 색상 속성을 가지고 있는 이진 탐색 트리이다. 이진 탐색 트리가 가지고 있는 일반적인 조건에 다음과 같은 추가적인 조건을 만족해야 유효한(valid) 레드-블랙 트리가 된다.

    - 노드는 레드 혹은 블랙 중의 하나이다.
    - 루트 노드는 블랙이다.
    - 모든 리프 노드들(NIL)은 블랙이다.
    - 레드 노드의 자식노드 양쪽은 언제나 모두 블랙이다. (즉, 레드 노드는 연달아 나타날 수 없으며, 블랙 노드만이 레드 노드의 부모 노드가 될 수 있다)
    - 어떤 노드로부터 시작되어 그에 속한 하위 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있다.  

    ![image](https://user-images.githubusercontent.com/108858121/209499462-469e1c87-2b55-4257-9828-cc8f06fbb055.png)

    위 조건들을 만족하게 되면, 레드-블랙 트리는 가장 중요한 특성을 나타내게 된다: 루트 노드부터 가장 먼 잎노드 경로까지의 거리가, 가장 가까운 잎노드 경로까지의 거리의 두 배 보다 항상 작다. 다시 말해서 레드-블랙 트리는 개략적(roughly)으로 균형이 잡혀 있다(balanced). 따라서, 삽입, 삭제, 검색시 최악의 경우(worst-case)에서의 시간복잡도가 트리의 높이(또는 깊이)에 따라 결정되기 때문에 보통의 이진 탐색 트리에 비해 효율적이라고 할 수 있다.

- **힙(heap)**  

    ![image](https://user-images.githubusercontent.com/108858121/209893769-51c0a668-48cd-418d-8da5-e5f350df4d3e.png)

    힙은 이진트리의 일종이다.
    반정렬 상태(정렬된 상태가 아니다)이며, 완전이진트리와는 다르게 중복값이 허용된다.
    삽입/삭제는 트리 구조이기 때문에 O(logN)이므로 매우 빠르다.

    힙은 최대힙, 최소힙으로 나뉘어진다. 최대힙은 부모노드가 자식노드보다 큼 이라는 특징을 가지고 최소힙은 부모노드가 자식노드보다 작음 이라는 특징을 가지고 있다. 이러한 특징으로 힙에 값을 넣게 되면 최소힙에서는 최소값 순으로, 최대힙에서는 최대값 순으로 값을 얻을 수 있다.  

    **<최대힙의 삽입>**

    ![image](https://user-images.githubusercontent.com/108858121/209893960-378c49cf-6203-4a71-a3c4-afb0f6c004ba.png)

- **우선순위 큐 (priority queue)**  
    우선순위 큐는 힙과 배열 또는 연결리스트를 이용하여 구현할 수 있다.

    하지만 배열과 연결리스트는 선형 구조의 자료구조이므로 삽입 또는 삭제 연산을 위한 시간복잡도는 O(n)이다.

    반면 힙트리는 완전이진트리 구조이므로 힙트리의 높이는 log₂(n+1)이며, 힙의 시간복잡도는 O(log₂n)이다.

    **<힙으로 구현한 우선순위 큐>**  

    힙은 일반적으로 배열을 이용하여 구현한다. 
    완전 이진트리에 가까워 중간에 비어있는 요소가 없기 때문이다.

    ![image](https://user-images.githubusercontent.com/108858121/209898537-eaf772b7-7350-4523-bbf6-aa1b2823d40b.png)

<br>

## **맵(Map)**  

키와 데이터(key-value)를 같이 저장할 수 있는 자료구조

![image](https://user-images.githubusercontent.com/108858121/209899784-2e8d7468-bf9a-4ebc-8fa5-39a8dbec23c3.png)

### **특징**
- Key, Value의 한 쌍으로 이루어진 데이터의 집합
- Key에는 중복된 값이 입력될 수 없다.
- 순서가 유지되지 않는다.
- Value의 중복은 허용된다.


### **장점**
- 뛰어난 검색 속도를 갖고 있다.
- 인덱스가 따로 존재하지 않기 때문에 iterator를 사용한다.

<br>

## **셋(Set)**
순서없고 중복이 존재할 수 없는 자료구조이다. 우리가 흔히 수학에서 배웠던 집합의 개념과 같다. 파이썬 set()함수와 같음

![image](https://user-images.githubusercontent.com/108858121/209900151-92e9fb80-cf65-4811-b0f1-0050e86fd3aa.png)

### **특징**
- 인덱스를 사용하지 않는다.
- 인덱스 매개변수가 없다.
- 집합에 빗대어 생각하면 좋을만한 자료구조

### **장점**
- 빠른 검색 속도를 갖고 있다.
- 인덱스가 따로 존재하지 않기 때문에 iterator를 사용한다.

### **사용시 유리할 때**
- 중복된 값을 골라내야 할 때 (고유값을 얻고자 할 때)
- 빠른 Look Up을 해야 할 때
- 순서는 상관 없을 때

<br>

## **해시 테이블(Hash table)**
해시 테이블이란 해시함수를 사용하여 변환한 값을 인덱스로로 삼아 키(key)와 데이터(value)를 저장하는 자료구조를 말한다. 기본연산으로는 탐색(Search), 삽입(Insert), 삭제(Delete)가 있다.

### **특징**
- 파이썬에서는 딕셔너리(Dictionary) 타입이 해쉬 테이블과 같은 구조
- 기본적으로 배열로 미리 Hash Table 크기만큼 생성해서 사용한다.

### **장점**
데이터 저장/검색 속도가 빠르다.
해쉬는 키에 대한 데이터가 있는지(중복) 확인이 쉽다.

### **사용시 유리할 때**
검색이 많이 필요한 경우, 저장, 삭제, 읽기가 많은 경우, 캐쉬를 구현할 때 주로 사용됨


<br>

### **참조**
https://coding-factory.tistory.com/610  
https://cow-coding.tistory.com/47  
https://velog.io/@kimdukbae/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%8A%B8%EB%A6%AC-Tree  
https://blog.naver.com/growth_s/222684312487  
https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC  
https://go-coding.tistory.com/25  